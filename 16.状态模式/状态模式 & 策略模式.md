# 2.状态模式 & 策略模式

- 开放封闭原则
- 委托思想
- 状态模式的关键是区分事物内部的状态，事物内部状态的改变往往会带来事物的行为改变。

## 概览

1.开灯-弱光-强光-开灯… 2.上传文件 3.游戏状态

状态模式的定义：允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类。
第一部分的意思是将状态封装成独立的类，并将请求委托给当前的状态对象，当对象的内部状态改变时，会带来不同的行为变化。电灯的例子足以说明这一点，在 off 和 on 这两种不同的状态下，我们点击同一个按钮，得到的行为反馈是截
然不同的。
第二部分是从客户的角度来看，我们使用的对象，在不同的状态下具有截然不同的行为，这个对象看起来是从不同的类中实例化而来的，实际上这是使用了委托的效果。

## 实现

1.把每种状态封装成单独的类，此种状态有关的行为都封装在类的内部
State{light context, btnWasPressed Func ()=>{this.light.curState = 下一个状态} }
OffState extends State{}
WeakState extends State{}
StrongState extends State{}

2.在上下文中把请求委托给当前的状态对象
Light context{curState 当前状态} —> this.curState.btnWasPressed

3.还可以把状态的切换规则事先分布在状态中，消除条件分支语句

## 优点：

1.context 上下文的请求动作，和状态类中封装的行为，独立互不干扰 2.定义了状态与行为之间的关系，并将其封装在类里。使新增、转移状态变得简单 3.去掉了 context 过多的条件分支

## 缺点：

1.在的系统中定义了许多状态类对象 2.逻辑分散在了状态类中

## 性能优化点：

1.管理 State 对象的创建销毁：
方法 1：只有在需要 state 对象时才创建并随后销毁—>state 对象比较庞大时采用，节省内存，避免创建不会用到的对象并及时回收它们
方法 2：一开始就创建好所有的状态对象，并始终不销毁—>状态的改变很频繁时采用 2.结合享元模式，各 context 共享一个 state 对象

## &策略模式：

1.管理 State 对象的创建销毁：


|  | 状态模式 |策略模式
| --- | --- |--- |
相同点—>类图看起来几乎一样| 都有上下文，策略 or 类，上下文把请求委托给这些类执行 |   |
不同点—>意图迥然不同| 每个状态的行为独立封装，状态的切换被规定完成，改变行为发生在状态模式内部 | 各个策略间平等平行独立无联系  |
| 用户无需了解状态行为的细节 | 各个策略间平等平行独立无联系  | 用户必须熟知策略类的作用以便切换算法
 




## 字面量+Function.prototype.call&delegate 函数：

```js
var delegate = function (client, delegation) {
  return {
    buttonWasPressed: function () {
      // 将客户的操作委托给 delegation 对象
      return delegation.buttonWasPressed.apply(client, arguments);
    },
  };
};
this.offState = delegate(this, FSM.off);
```
